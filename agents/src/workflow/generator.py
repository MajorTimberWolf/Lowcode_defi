"""
Workflow Generator

Converts AI agent requirements into WorkflowDefinition format compatible with 
the TypeScript DeFi Execution Engine backend.
"""

import uuid
from datetime import datetime
from typing import Dict, List, Any, Optional
import json
import structlog

logger = structlog.get_logger()

class WorkflowGenerator:
    """
    Generates workflow definitions from AI agent requirements.
    
    Converts structured requirements from the ArchitectureMapperAgent into
    the WorkflowDefinition format expected by the TypeScript backend.
    """
    
    def __init__(self):
        self.logger = logger.bind(component="WorkflowGenerator")
        
    async def generate_workflow(self, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate a WorkflowDefinition from AI agent requirements
        
        Args:
            requirements: Structured requirements from ArchitectureMapperAgent
            
        Returns:
            WorkflowDefinition compatible with TypeScript backend
        """
        self.logger.info("Generating workflow", pattern=requirements.get('pattern'))
        
        workflow_id = str(uuid.uuid4())
        timestamp = datetime.utcnow().isoformat() + "Z"
        
        # Generate nodes based on suggested_nodes
        nodes = self._generate_nodes(requirements)
        
        # Generate edges to connect the nodes
        edges = self._generate_edges(nodes)
        
        workflow_definition = {
            "id": workflow_id,
            "name": self._generate_workflow_name(requirements),
            "description": requirements.get('user_intent', 'DeFi workflow generated by AI agent'),
            "nodes": nodes,
            "edges": edges,
            "metadata": {
                "created": timestamp,
                "modified": timestamp,
                "version": "1.0.0",
                "author": "DeFi Agent System",
                "pattern": requirements.get('pattern', 'Custom'),
                "tokens": requirements.get('tokens', []),
                "features": requirements.get('features', []),
                "chains": requirements.get('chains', ['ethereum'])
            }
        }
        
        self.logger.info("Workflow generated", 
                        workflow_id=workflow_id,
                        node_count=len(nodes),
                        edge_count=len(edges))
        
        return workflow_definition
        
    def _generate_workflow_name(self, requirements: Dict[str, Any]) -> str:
        """Generate a human-readable name for the workflow"""
        pattern = requirements.get('pattern', 'DeFi Application')
        tokens = requirements.get('tokens', [])
        
        if tokens:
            token_str = ", ".join(tokens[:3])  # Limit to first 3 tokens
            if len(tokens) > 3:
                token_str += "..."
            return f"{pattern} ({token_str})"
        else:
            return pattern
            
    def _generate_nodes(self, requirements: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate nodes based on suggested_nodes from AI agent"""
        
        suggested_nodes = requirements.get('suggested_nodes', [])
        tokens = requirements.get('tokens', [])
        features = requirements.get('features', [])
        chains = requirements.get('chains', ['ethereum'])

        # Map certain patterns directly to predefined template node sequences
        pattern = requirements.get('pattern')
        if pattern == 'DEX Aggregator':
            # Rich DeFi suite template mirroring frontend "dex-aggregator-swap" template
            suggested_nodes = [
                'walletConnector',
                'tokenSelector',
                'oneInchQuote',
                'priceImpactCalculator',
                'oneInchSwap',
                'fusionSwap',
                'limitOrder',
                'portfolioAPI',
                'transactionMonitor',
                'defiDashboard'
            ]
        elif pattern == 'Cross-Chain Bridge':
            suggested_nodes = [
                'walletConnector',
                'chainSelector',
                'fusionPlus',
                'transactionMonitor',
                'defiDashboard'
            ]
        
        nodes = []
        
        for i, node_type in enumerate(suggested_nodes):
            node_id = f"{node_type}-{i+1}"
            
            node = {
                "id": node_id,
                "type": node_type,
                "position": {"x": 100 + (i * 250), "y": 100 + (i % 3) * 150},  # Simple layout
                "data": {
                    "label": self._get_node_label(node_type),
                    "config": self._generate_node_config(node_type, requirements)
                }
            }
            
            nodes.append(node)
            
        return nodes
        
    def _generate_node_config(self, node_type: str, requirements: Dict[str, Any]) -> Dict[str, Any]:
        """Generate configuration for specific node types"""
        
        tokens = requirements.get('tokens', [])
        features = requirements.get('features', [])
        chains = requirements.get('chains', ['ethereum'])
        
        # Convert chain names to chain IDs
        chain_ids = []
        chain_mapping = {
            'ethereum': 1,
            'polygon': 137,
            'arbitrum': 42161,
            'optimism': 10,
            'bsc': 56,
            'avalanche': 43114
        }
        
        for chain in chains:
            if isinstance(chain, str):
                chain_ids.append(chain_mapping.get(chain.lower(), 1))
            else:
                chain_ids.append(chain)
        
        # Base config for template mode - ALL nodes need this
        config = {
            "template_creation_mode": True,
            "mode": "template"
        }
        
        if node_type == 'walletConnector':
            config.update({
                "supported_wallets": ["metamask", "walletconnect", "coinbase"],
                "supported_chains": chain_ids,
                "auto_connect": True,
                "require_wallet_approval": True
            })
            
        elif node_type == 'tokenSelector':
            # Convert token symbols to proper format for template mode
            default_tokens = []
            for token in (tokens or ["ETH", "USDC", "WBTC"]):
                default_tokens.append(token.upper())
                
            config.update({
                "default_tokens": default_tokens,
                "supported_chains": chain_ids,
                "include_metadata": True,
                "price_source": "1inch",
                "enable_custom_tokens": True
            })
            
        elif node_type == 'chainSelector':
            config.update({
                "supported_chains": chain_ids,
                "default_chain": chain_ids[0] if chain_ids else 1,
                "enable_multichain": len(chain_ids) > 1
            })
            
        elif node_type == 'oneInchQuote':
            quote_config = {
                "default_slippage": 1.0,  # 1% default slippage
                "supported_chains": chain_ids,
                "enable_pathfinder": True,
                "gas_optimization": "balanced"
            }
            
            # Add slippage protection if requested
            if 'slippage protection' in features:
                quote_config["max_slippage"] = 3.0
                quote_config["slippage_warning"] = True
                
            config.update(quote_config)
                
        elif node_type == 'oneInchSwap':
            swap_config = {
                "default_slippage": 1.0,
                "supported_chains": chain_ids,
                "enable_fusion": 'MEV protection' in features,
                "gas_optimization": "balanced",
                "enable_referrer": False
            }
            
            config.update(swap_config)
            
        elif node_type == 'priceImpactCalculator':
            config.update({
                "warning_threshold": 3.0,  # 3% price impact warning
                "max_impact_threshold": 15.0,  # 15% max impact
                "include_slippage": True,
                "detailed_analysis": True,
                "supported_chains": chain_ids
            })
            
        elif node_type == 'transactionMonitor':
            monitor_config = {
                "default_confirmations": 1,
                "timeout_minutes": 10,
                "enable_alerts": True,
                "include_gas_tracking": True,
                "supported_chains": chain_ids
            }
            
            if 'MEV protection' in features:
                monitor_config["enable_mev_detection"] = True
                
            config.update(monitor_config)
            
        elif node_type == 'fusionPlus':
            config.update({
                "supported_source_chains": chain_ids,
                "supported_destination_chains": chain_ids,
                "enable_mev_protection": True,
                "bridge_mode": "fast",
                "min_bridge_amount": "0.01"
            })
            
        elif node_type == 'portfolioAPI':
            config.update({
                "supported_chains": chain_ids,
                "include_tokens": True,
                "include_protocols": True,
                "include_pnl": True,
                "refresh_interval": 60,  # seconds
                "enable_historical_data": True
            })
            
        elif node_type == 'limitOrder':
            config.update({
                "supported_chains": chain_ids,
                "default_order_type": "limit",
                "enable_partial_fills": True,
                "auto_renewal": False,
                "default_expiration_days": 30
            })
            
        elif node_type == 'fusionSwap':
            config.update({
                "supported_chains": chain_ids,
                "gasless": True,
                "mev_protection": True,
                "resolver_mode": "auto"
            })
            
        elif node_type == 'transactionStatus':
            config.update({
                "supported_chains": chain_ids,
                "track_confirmations": True,
                "include_gas_analysis": True,
                "show_timeline": True,
                "default_confirmation_target": 1
            })
        
        elif node_type == 'defiDashboard':
            config.update({
                "title": requirements.get('metadata', {}).get('appName', 'DeFi Dashboard'),
                "show_portfolio": True,
                "enable_multi_swap": True,
                "enable_limit_orders": True,
                "show_analytics": True,
                "default_theme": "dark",
                "default_layout": "grid",
                "default_components": [
                    "wallet-connector",
                    "token-selector",
                    "swap-interface",
                    "transaction-history",
                    "portfolio-tracker"
                ],
                "enable_branding": False
            })
        
        elif node_type == 'erc20Token':
            config.update({
                "supported_chains": chain_ids,
                "enable_custom_tokens": True,
                "include_token_metadata": True
            })
            
        # Add template-specific configuration
        if requirements.get('pattern') in self._get_template_configs():
            template_config = self._get_template_configs()[requirements['pattern']]
            if node_type in template_config:
                config.update(template_config[node_type])
                
        return config
        
    def _get_node_label(self, node_type: str) -> str:
        """Get human-readable label for node type"""
        
        labels = {
            'walletConnector': 'Wallet Connection',
            'tokenSelector': 'Token Selector',
            'chainSelector': 'Chain Selector', 
            'oneInchQuote': '1inch Quote',
            'oneInchSwap': '1inch Swap',
            'priceImpactCalculator': 'Price Impact Calculator',
            'transactionMonitor': 'Transaction Monitor',
            'transactionStatus': 'Transaction Status',
            'fusionPlus': 'Fusion+ Cross-Chain',
            'portfolioAPI': 'Portfolio Tracker',
            'limitOrder': 'Limit Order',
            'fusionSwap': 'Fusion Swap',
            'defiDashboard': 'DeFi Dashboard',
            'erc20Token': 'ERC20 Token'
        }
        
        return labels.get(node_type, node_type.title())
        
    def _generate_edges(self, nodes: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate edges to connect nodes in a logical flow"""
        
        edges = []
        
        if len(nodes) < 2:
            return edges
            
        # Create a simple linear flow by default
        for i in range(len(nodes) - 1):
            edge_id = f"edge-{i+1}"
            source_id = nodes[i]['id'] 
            target_id = nodes[i+1]['id']
            
            edge = {
                "id": edge_id,
                "source": source_id,
                "target": target_id,
                "sourceHandle": "output",
                "targetHandle": "input"
            }
            
            edges.append(edge)
            
        # Add intelligent edge routing based on node types
        edges = self._optimize_edge_routing(nodes, edges)
        
        return edges
        
    def _optimize_edge_routing(self, nodes: List[Dict[str, Any]], edges: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Optimize edge routing based on node types and dependencies"""
        
        # For now, return the simple linear edges
        # TODO: Implement more sophisticated routing based on node dependencies
        return edges
        
    def _get_template_configs(self) -> Dict[str, Dict[str, Dict[str, Any]]]:
        """Get template-specific configuration overrides"""
        
        return {
            "DEX Aggregator": {
                "oneInchQuote": {
                    "preferred_protocols": ["uniswap_v3", "curve", "balancer"],
                    "enable_gas_estimation": True,
                    "default_slippage": 1.0  # Conservative for DEX
                },
                "priceImpactCalculator": {
                    "warning_threshold": 2.0,  # More conservative for DEX
                    "detailed_analysis": True
                }
            },
            "Cross-Chain Bridge": {
                "fusionPlus": {
                    "bridge_mode": "secure",  # Prioritize security over speed
                    "min_confirmations": 3
                },
                "transactionMonitor": {
                    "default_confirmations": 3,  # More confirmations for cross-chain
                    "timeout_minutes": 30
                }
            },
            "Portfolio Dashboard": {
                "portfolioAPI": {
                    "enable_historical_data": True,
                    "include_pnl": True,
                    "refresh_interval": 30
                }
            }
        }
        
    async def validate_workflow(self, workflow: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate a generated workflow definition
        
        Args:
            workflow: The workflow definition to validate
            
        Returns:
            Validation result with any errors
        """
        errors = []
        warnings = []
        
        # Check required fields
        required_fields = ['id', 'name', 'nodes', 'edges']
        for field in required_fields:
            if field not in workflow:
                errors.append(f"Missing required field: {field}")
                
        # Validate nodes
        if 'nodes' in workflow:
            for i, node in enumerate(workflow['nodes']):
                node_errors = self._validate_node(node, i)
                errors.extend(node_errors)
                
        # Validate edges
        if 'edges' in workflow and 'nodes' in workflow:
            edge_errors = self._validate_edges(workflow['edges'], workflow['nodes'])
            errors.extend(edge_errors)
            
        # Check for common issues
        if 'nodes' in workflow and len(workflow['nodes']) == 0:
            warnings.append("Workflow has no nodes")
            
        return {
            'valid': len(errors) == 0,
            'errors': errors,
            'warnings': warnings
        }
        
    def _validate_node(self, node: Dict[str, Any], index: int) -> List[str]:
        """Validate a single node"""
        errors = []
        
        required_fields = ['id', 'type', 'data']
        for field in required_fields:
            if field not in node:
                errors.append(f"Node {index}: Missing required field '{field}'")
                
        if 'data' in node and 'config' not in node['data']:
            errors.append(f"Node {index}: Missing 'config' in data")
            
        return errors
        
    def _validate_edges(self, edges: List[Dict[str, Any]], nodes: List[Dict[str, Any]]) -> List[str]:
        """Validate edges against nodes"""
        errors = []
        
        node_ids = {node['id'] for node in nodes}
        
        for i, edge in enumerate(edges):
            if 'source' not in edge or 'target' not in edge:
                errors.append(f"Edge {i}: Missing source or target")
                continue
                
            if edge['source'] not in node_ids:
                errors.append(f"Edge {i}: Source node '{edge['source']}' does not exist")
                
            if edge['target'] not in node_ids:
                errors.append(f"Edge {i}: Target node '{edge['target']}' does not exist")
                
        return errors