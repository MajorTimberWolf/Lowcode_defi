You are an expert in building modular AI agent systems that can construct DeFi flows from natural language using Python, FastAPI, and LangChain.

## Core Architecture

### System Overview
- **Architecture Mapping Agent**: Main conversational agent that understands user requirements and creates node flows
- **Multi-Agent System**: Specialized agents for trading, risk management, portfolio optimization, and yield farming
- **Node-Based Flow Generation**: Create visual flows that can be executed as code
- **Git Integration**: Auto-commit generated code to user repositories

### Key Components
1. **ConversationalMapper**: Main interface processing user input through multiple specialized agents
2. **NodeLibrary**: Repository of reusable DeFi components (swap, bridge, lending, DAO nodes)
3. **TemplateMatcher**: AI-powered template matching for common DeFi patterns
4. **NodeGenerator**: Converts agent responses into executable node flows
5. **CodeGenerator**: Transforms flows into full-stack applications

## Technical Stack

### Backend (Python)
- **FastAPI/Flask**: API server with endpoints (`/save-flow`, `/generate-code`, `/push-to-git`)
- **LangChain**: AI agent orchestration and conversation memory
- **GitPython**: Automated repository management and code deployment
- **Pandas/NumPy**: Data analysis for market operations

### Development Environment
- **Conda Environment**: `unite-defi` - All development should be done within this environment
- **Package Manager**: `uv` - Use for fast Python package installation and dependency management
- **Python Version**: Ensure compatibility with conda environment specifications

### AI Integration
- Use **agno-agi** as the primary agentic system (refer to docs.agno.com)
- Study **Langflow** patterns for flow construction (refer to docs.langflow.org)
- Implement conversation memory and multi-turn dialogue capabilities

## Code Structure Guidelines

### 1. Modular Agent Architecture
```python
class ArchitectureMapperAgent:
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4")
        self.node_library = NodeLibrary()
        self.template_matcher = TemplateMatcher()
    
    async def map_user_idea(self, user_input: str) -> NodeFlow:
        # Extract requirements, match templates, generate flows
```

### 2. Flow Processing Logic
- Parse user requirements into structured data (JSON format)
- Identify main functionality (swap, bridge, lending, DAO, etc.)
- Extract tokens/chains, automation needs, UI requirements
- Generate appropriate node combinations with proper connections

### 3. Code Generation Patterns
- Analyze node connections and validate flow logic
- Generate backend Python code (API endpoints, agent scripts)
- Create frontend components for node visualization
- Output complete full-stack structure with proper file organization

### 4. Git Integration
- Auto-create/clone user repositories
- Generate meaningful commit messages based on flow descriptions
- Handle branch management and basic CI/CD configuration
- Push generated code with proper project structure

## Development Environment Setup

### Conda Environment Management
- Always activate the `unite-defi` conda environment before development
- Use `conda activate unite-defi` at the start of each session
- Ensure all Python dependencies are installed within this environment
- Keep environment.yml or requirements.txt files updated for reproducibility

### Package Management with uv
- **Option 1: Full uv Project Management** (Recommended for new projects)
  - Initialize uv project: `uv init` (creates pyproject.toml)
  - Install packages with `uv add <package_name>`
  - Use `uv sync` to synchronize dependencies
  - Run scripts with `uv run python script.py`

- **Option 2: uv as pip replacement** (Current setup - faster pip)
  - Use `uv pip install <package_name>` for faster installation
  - Continue using conda environment activation
  - No pyproject.toml created (works like regular pip)

### Environment Commands
```bash
# Activate conda environment (always required)
conda activate unite-defi

# Option 1: Full uv project (if initialized)
uv init                                    # Initialize project (creates pyproject.toml)
uv add fastapi langchain pandas numpy gitpython agno anthropic
uv run python main.py
uv sync

# Option 2: uv as pip replacement (current setup)
uv pip install fastapi langchain pandas numpy gitpython agno anthropic
python main.py                            # Run normally after conda activate

# Current packages installed
uv pip list                               # See installed packages
```

## Implementation Rules

### Agent Design
- Each agent should be specialized (trading, risk, optimization, farming)
- Implement conversation memory using ConversationBufferMemory
- Use intent classification to route requests to appropriate agents
- Generate unified responses combining multiple agent outputs

### Flow Construction
- Create reusable node templates for common DeFi operations
- Implement proper error handling and validation for node connections
- Support conditional logic (IF/THEN nodes) as Python functions
- Enable data transformation between connected nodes

### API Design
- Design RESTful endpoints for flow operations
- Implement proper request/response validation
- Support real-time flow execution and monitoring
- Provide debugging capabilities for generated flows

### Code Quality
- Write type-annotated Python code
- Implement comprehensive error handling
- Use async/await for better performance
- Follow clean architecture principles with clear separation of concerns
- Ensure all code runs properly within the `unite-defi` conda environment
- Use `uv` for dependency management and package installation
- Test code execution with `uv run` to verify environment compatibility

## Example Patterns

### User Interaction Flow
```
User: "Create a swap application for ETH, USDC, WBTC with slippage protection"
↓
Intent Classification → Architecture Mapping
↓
Node Generation: Wallet → Token Selector → Quote → Price Calculator → Execution
↓
Code Generation → Git Push → Deployment
```

### Node Connection Logic
- Validate data flow between nodes
- Ensure proper typing and format conversion
- Implement error propagation and rollback mechanisms
- Support parallel execution where appropriate

## Reference Documentation
- **agno-agi**: docs.agno.com - Primary agentic system documentation
- **Langflow**: docs.langflow.org - Flow construction patterns and best practices

## Testing Strategy
- Unit tests for individual agents and nodes
- Integration tests for complete flow execution
- Mock external APIs (DEX aggregators, blockchain RPCs)
- Test code generation output for correctness and completeness
- Run all tests within the `unite-defi` conda environment
- Use `uv run pytest` if using full uv project, or `python -m pytest` if using uv as pip replacement
- Ensure test dependencies are managed consistently with your chosen uv approach

## Project Structure
```
unite-defi/
├── pyproject.toml          # uv project configuration (if using uv init)
├── environment.yml         # conda environment specification
├── requirements.txt        # Alternative to pyproject.toml for pip-style workflow
├── src/
│   ├── agents/            # AI agent implementations
│   ├── nodes/             # Node library and templates
│   ├── flows/             # Flow processing logic
│   └── api/               # FastAPI endpoints
├── tests/                 # Test suite
└── generated/             # Output for generated code
```

Focus on building a system that can understand natural language DeFi requirements and automatically generate working, deployable applications through intelligent agent coordination and modular flow construction.